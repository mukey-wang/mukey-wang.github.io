{"posts":[{"title":"EasyAnticheat的内存特征算法","content":"anticheat一般都会有内存扫描的操作，来与数据库中的非法程序进行对比。 在进行扫描前，ac会先判断地址是否正确 判断是否是用户态的可读地址 如果没问题，则进行内存特征的操作 根据这个这个表，很容易知道这是hde的反汇编引擎,和crc的哈希 具体步骤: 1.eac先根据获取当前附加进程的架构x86,还是x64 2.接着开始循环遍历内存块,直到找到特定机器码起始的地址 可以看到，x64是寻找sub rsp,xxxx /push rbp或者mov rbp,rsp 。x86则是寻找push ebp /mov ebp,esp 3.如果找不到，则+0x10个字节继续寻找。如果找到了，先计算当前指令的crc(x64 4个字节,x86 3个字节,这里crc的初始值是0)，接着开始遍历下面的内存 从上面找到地址来看，判断架构，x先用hde尝试获取指令长度，如果反汇编成功，64则判断是否是否0x48或0x0f开头，则crc 2个字节，否则只crc一个字节。x86同理,直到碰到inst_filter中的opcode为止,输出看一下 碰到这些opcode则结束循环，并把计算的crc保存到全局数组中 下面来仿写这个算法试试,对ntdll的.text段进行提取特征 ","link":"https://mukey-wang.github.io/post/easyanticheat-de-nei-cun-te-zheng-suan-fa/"},{"title":"仿制Getting Over It","content":"项目地址：https://github.com/mukey-wang/GettingOverIt 教程之后在写😇 ","link":"https://mukey-wang.github.io/post/fang-zhi-getting-over-it/"},{"title":"从零开始数据结构1——基础算法","content":"基础算法 1. 排序 快速排序 归并排序 2. 二分 整数二分 浮点二分 3. 高精度[1] 高精度加法（L+L） 高精度减法（L-L） 高精度乘法（L*N) 高精度除法（L/N） 4. 前缀和与差分 一维前缀和 二维前缀和 一维差分 二维差分 5. 双指针算法 6. 位运算 7. 离散化 8. 区间合并 L表示长度小于等于len(18)的数，N表示数的范围为int ↩︎ ","link":"https://mukey-wang.github.io/post/cong-ling-kai-shi-shu-ju-jie-gou-1-ji-chu-suan-fa/"}]}